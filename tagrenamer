#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#
# tagrenamer - Music file renamer
#
# @description
#  This script is a one-purpose rewriter for trees with music files. It iterates
#  trough a file hierarchy and fetches common music tags from each sound file it
#  finds and supports and uses this data to create a new file and directory
#  structure. Files found in the old hierarchy are placed in a directory
#  called "__LEFTOVERS" to not lose anything.
#
# @author
#  Niels van Mourik <niels@nielsvm.org>
#

# pylint: disable=C0103 # invalid-name
# pylint: disable=C0116 # missing-function-docstring
# pylint: disable=R0913 # too-many-arguments
# pylint: disable=R0912 # too-many-branches

import optparse
import os
import sys

def __option_parser():
    """Configure the option parser."""
    usage = "usage: %prog [OPTIONS]... [DIRECTORY]"
    parser = optparse.OptionParser(usage=usage)
    parser.add_option(
        "-d", "--dry-run",
        action="store_true", dest="dryrun", default=False,
        help="Perform a dry run and don't touch anything.")
    parser.add_option(
        "-f", "--format",
        action="store", type="string", dest="format", metavar='F',
        default='{artist}/{album}/{artist}-{hash}.{ext}',
        help="The format in which filenames will be rewritten.")
    parser.add_option(
        "-l", "--leftovers",
        action="store", type="string", dest="leftoversdir", metavar='L',
        default='__LEFTOVERS',
        help="The directory where non-music files will be moved to.")
    parser.add_option(
        "-S", "--stagedir",
        action="store", type="string", dest="stagedir", metavar='S',
        default='__STAGE',
        help="Temporary directory before music hits its final spot.")
    parser.add_option(
        "-s", "--shell",
        action="store_true", dest="shell", default=False,
        help="Generate and print shell commands (implies -q and -d)")
    parser.add_option(
        "-q", "--quiet",
        action="store_true", dest="quiet", default=False,
        help="Silence all output completely, including debugging.")
    parser.add_option(
        "-v", "--verbose",
        action="count", dest="debuglevel", default=False, metavar='V',
        help="The level of logging verbosity, up to 5 v's.")
    (options, args) = parser.parse_args()
    return {'options': options, 'parser': parser, 'args': args}


def __option_validator(settings):
    """Validate the given arguments and prepare the options object."""

    if not len(settings['args']):
        settings['parser'].print_help()
        sys.exit(0) # ok

    # Store the mandatory directory argument as setting key "dir".
    settings['options'].dir = str(settings['args'][0]).strip()

    # Test whether the path exists.
    if not os.path.exists(settings['options'].dir):
        print("ERROR: Directory '%s' not found!\n" % settings['options'].dir)
        settings['parser'].print_help()
        sys.exit(3) # ERROR

    # Test whether the path is a directory as it should be.
    if not os.path.isdir(settings['options'].dir):
        print("ERROR: Path '%s' is not a directory!\n" % settings['options'].dir)
        settings['parser'].print_help()
        sys.exit(3) # ERROR

    # Enforce dry-run and quiet mode when --shell is passed.
    if settings['options'].shell:
        settings['options'].quiet = True
        settings['options'].dryrun = True

    # De-construct the parser and arguments and return the settings object.
    del(settings['parser'])
    del(settings['args'])
    return settings['options']


if __name__ == "__main__":
    try:
        from lib import Collection
        from lib import Output
    except ImportError as e:
        print("ERROR: %s\n\nConsider installing packages, e.g.:" % e)
        print(" $ zypper install python3*-pytaglib")
        print(" $ pip3 install transliterate")
        sys.exit(3) # Internal error.
    try:
        parser = __option_parser()
        settings = __option_validator(parser)

        out = Output()
        out.set_debuglevel(settings.debuglevel)
        out.set_quiet(settings.quiet)
        out.log(context = __name__)

        coll = Collection(out, settings)
        coll.process()
    except RuntimeError:
        sys.exit(1)
    except KeyboardInterrupt:
        print(" Quitting...")
        sys.exit(-1)
