#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# mrenamer - Music file renamer
#
# @description
#  This script is a one-purpose rewriter for trees with music files. It iterates
#  trough a file hierarchy and fetches common music tags from each sound file it
#  finds and supports and uses this data to create a new file and directory
#  structure. Files found in the old hierarchy are placed in a directory
#  called "__LEFTOVERS" to not lose anything.
#
# @author
#  Niels van Mourik <niels@nielsvm.org>
#

## CLASSES #####################################################################

#
# Translate a string into a absolutely safe file system friendly representation.
#
class SafeString():
  whitelist = ('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o',
    'p','q','r','s','t','u','v','w','x','y','z','-','.', ' ', '0', '1', '2',
    '3', '4', '5', '6', '7', '8', '9')
  original = string = ''

  # Initialize the string object.
  def __init__(self, string):
    string = unicode(string)
    self.original = string
    self.string = string.lower()
    decomposed = normalize("NFKD", self.string)
    self.string = ''.join(c for c in decomposed if ord(c)<0x7f)
    self.filter()

  # Filter out any garbage left.
  def filter(self):
    result = []
    for char in self.string:
      for validchar in self.whitelist:
        if char == validchar:
          result.append(char)
    self.string = ''.join(result)

  def __str__(self):
    return self.string

#
# Represent any file, directory or other reference found on the file system.
#
#   Provided hooks:
#    - init (obj)
#    - remove (obj)
#    - move (obj, dest)
#
class Node():
  dl = 1 # Short for debuglevel.
  type = ''
  path = relpath = ''
  base = ''
  root = ''
  hooks = {}
  dryrun = False
  parent = None

  # Initialize the file-system node container
  def __init__(self, path, hooks={}, parent=None, dl=1):
    self.type = self.__class__.__name__
    self.path = os.path.abspath(path)
    self.base = os.path.basename(self.path)
    self.dryrun = False
    self.parent = parent
    if parent == None:
      if os.path.isdir(self.path):
        self.root = self.path
      else:
        self.root = os.path.dirname(self.path)
    else:
      self.root = self.parent.root
    self.hooks=hooks
    self.relpath = self.path.replace('%s/' % self.root, '')
    self.dl = self.dl + dl
    debug("'%s' __init__()" % self, self.dl)

    # Invoke the init hook, see main class description.
    self.invoke('init', self)

  # Format our own base representation.
  def __str__(self):
    return "%s:%s" % (self.type, self.base)

  # Invoke the given hook when they have been registered at object construction.
  def invoke(self, hook, *args):
    if len(self.hooks) is 0:
      return
    if hook in self.hooks:
      return self.hooks[hook](*args)

  # Enable a dry-run mode on this object so that no real will things happen.
  def enableDryRun(self):
    self.dryrun = True

  # Determine whether the object really exists or not.
  def exists(self):
    debug("'%s' exists()" % self, self.dl)
    return os.path.exists(self.path)

  # Delete the file system object from disk.
  def remove(self):
    debug("'%s' remove()" % self, self.dl)
    if not self.dryrun:
      os.unlink(self.path)

    # Remove this instance from the parents list of children.
    if self.parent != None:
      self.parent.removeChild(self)

    # Invoke the remove hook, see main class description.
    self.invoke('remove', self)

  # Move the file system object onto a different location.
  def move(self, dest):
    debug("'%s' move()" % self, self.dl)

    # Declare the new path and physically move the object.
    self.oldpath = self.path
    self.path = os.path.abspath('%s/%s' % (dest.path, self.base))
    if not self.dryrun:
      os.rename(self.oldpath, self.path)

    # Unregister ourselves at our current parent and register at new parent.
    if self.parent:
      self.parent.removeChild(self)
      dest.addChild(self)

    # Re-parent ourselves and update several properties.
    self.parent = dest
    self.base = os.path.basename(self.path)
    self.dryrun = self.parent.dryrun
    self.root = self.parent.root
    self.relpath = self.path.replace('%s/' % self.root, '')
    self.dl = self.parent.dl + 1

    # Invoke the move hook, see main class description.
    self.invoke('move', self, dest)

#
# Represent an ordinary file found on the file system.
#
class File(Node):
  extension = ''

  # Initialize the file object after calling home.
  def __init__(self, path, extension, hooks={}, parent=None, dl=1):
    Node.__init__(
      self,
      path=path,
      hooks=hooks,
      parent=parent,
      dl=dl)

    # Set the extension if available.
    if '.' in self.base:
      self.extension = extension
    else:
      extension = ''

#
# Represent a file of a known music file format found on the file system.
#
#   Provided hooks:
#    - sanitize (obj)
#
class MusicFile(File):
  artist = ''
  album = ''
  title = ''
  artist_s = ''
  album_s = ''
  title_s = ''

  # Initialize the music file object after calling home.
  def __init__(self, path, extension, hooks={}, parent=None, dl=1):
    File.__init__(
      self,
      path=path,
      extension=extension,
      hooks=hooks,
      parent=parent,
      dl=dl)

    # Reset all meta data values of this music file.
    self.artist = self.album = self.title = ''
    self.artist_s = self.album_s = self.title_s = ''

  # Extract all meta data using the Tagpy library.
  def extract(self):
    debug("'%s' extract()" % self, self.dl)
    f = tagpy.FileRef(self.path, False)
    self.artist = f.tag().artist
    self.album = f.tag().album
    self.title = f.tag().title

  # Sanitize the extracted data ready for file system level usage.
  def sanitize(self):
    debug("'%s' sanitize()" % self, self.dl)
    self.artist_s = str(SafeString(self.artist.strip()))
    self.album_s = str(SafeString(self.album.strip()))
    self.title_s = str(SafeString(self.title.strip()))

    # Start validating the data, based on field length.
    if not len(self.artist_s):
      raise ValueError(self)
    elif not len(self.album_s):
      raise ValueError(self)
    elif not len(self.title_s):
      raise ValueError(self)

    # Invoke the sanitize hook, see main class description.
    self.invoke('sanitize', self)

#
# Represent a directory found on the file system.
#
#   Provided hooks:
#    - traverse_filter (obj, path), return True/False
#    - mkdir (obj)
#
class Directory(Node):
  children = []

  # Initialize the file object after calling home.
  def __init__(self, path, hooks={}, parent=None, dl=1):
    Node.__init__(
      self,
      path=path,
      hooks=hooks,
      parent=parent,
      dl=dl)
    self.children = []

  # Enable a dry-run mode on this object and its children.
  def enableDryRun(self):
    Node.enableDryRun(self)
    if len(self.children):
      for c in self.children:
        c.enableDryRun()

  # Add a child node.
  def addChild(self, child):
    children = []
    for c in self.children:
      children.append(c)
    children.append(child)
    self.children = children

  # Remove a child from this node.
  def removeChild(self, child):
    children = []
    for c in self.children:
      if c.path != child.path:
        children.append(c)
    self.children = children

  # Traverse into subdirectories and load our children.
  def traverse(self):
    self.children = []
    debug("'%s' traverse()" % self, self.dl)

    # Only really traverse if the object exists.
    if self.exists():
      for path in os.listdir(self.path):
        dl = self.dl + 1
        path = "%s/%s" % (self.path, path)

        # Invoke the traverse_filter hook (see main class description) and
        # determine if we should include this object (True) or not (False).
        filter_outcome = self.invoke('traverse_filter', self, path)
        if filter_outcome is not None:
          if filter_outcome == False:
            debug("'%s' traverse(): skipping %s" % (self, path), dl)
            continue

        # Perform a set of tests and load the correct class for the found child.
        if os.path.isdir(path):
          node = Directory(path=path, hooks=self.hooks, parent=self, dl=dl)
          node.traverse()
        elif os.path.isfile(path):
          music_extensions = ('mp3', 'ogg', 'flac')
          extension = path.split('.').pop()
          if extension in music_extensions:
            node = MusicFile(path=path, extension=extension, hooks=self.hooks, parent=self, dl=dl)
          else:
            node = File(path=path, extension=extension, hooks=self.hooks, parent=self, dl=dl)
        else:
          node = Node(path=path, hooks=self.hooks, parent=self, dl=dl)

        # Enable dry run if on the node if it applies to us.
        if self.dryrun:
          node.enableDryRun()

        # Append the child to our list of children.
        self.children.append(node)

  # Make this directory if it doesn't exist on disk yet.
  def mkdir(self):
    debug("'%s' mkdir()" % self, self.dl)
    if not self.dryrun:
      os.mkdir(self.path)

    # Invoke the mkdir hook, see main class description.
    self.invoke('mkdir', self)

  # Make multiple directories at once and assure that a path exists.
  def mkdirs(self, path):
    debug("'%s' mkdirs()" % self, self.dl)

    # Calculate the sub path and current base being looked for.
    path = path.split('/')
    base = path[0]
    del path[0]

    # Determine whether the top level of the trail already exists.
    existingDir = False
    for c in self.children:
      if c.base == base:
        existingDir = c

    # Load the new directory object and create it if needed.
    if not existingDir:
      dl = self.dl + 1
      npath = "%s/%s" % (self.path, base)
      dir = Directory(path=npath, hooks=self.hooks, parent=self, dl=dl)
      if self.dryrun:
        dir.enableDryRun()
      dir.mkdir()
      self.children.append(dir)
    else:
      dir = existingDir

    # Let the fresh directory object recurse into itself.
    if len(path):
      return dir.mkdirs('/'.join(path))
    return dir

  # Delete this directory and it's siblings from disk.
  def remove(self):
    debug("'%s' remove()" % self, self.dl)

    # Start with removing my children and their references.
    for c in self.children:
      c.remove()
    self.children = []

    # Remove the directory when it's emptied.
    if not self.dryrun:
      os.rmdir(self.path)

    # Remove this instance from the parents list of children.
    if self.parent != None:
      self.parent.removeChild(self)

  # Move the file system object onto a different location.
  def move(self, dest):
    debug("'%s' move()" % self, self.dl)
    raise Exception("Can not move directories yet...")

#
# Represent the collection of all found file objects within the base path.
#
class Collection():
  d_root = d_leftovers = d_stage = None
  directories = []
  musicfiles = []
  settings = None
  files = []
  nodes = []
  ids = []

  # Initialize the music collection.
  def __init__(self, settings):
    debug("'%s' __init__()" % self, 1)
    self.settings = settings

    # Initialize all directory objects: the root directory, the left-overs and stage directories.
    self.d_root = Directory(
      path=self.settings.dir,
      hooks={
        'init': self.callbackInit,
        'remove': self.callbackRemove,
        'move': self.callbackMove,
        'sanitize': self.callbackSanitize,
        'traverse_filter': self.callbackTraverseFilter,
        'mkdir': self.callbackMkdir})
    self.d_leftovers = Directory(
      path="%s/%s" % (self.d_root.path, self.settings.leftoversdir),
      parent=self.d_root,
      dl=2)
    self.d_stage = Directory(
      path="%s/%s" % (self.d_root.path, self.settings.stagedir),
      parent=self.d_root,
      dl=2)

    # If we run in --dry-run mode, enable it on all directory objects.
    if self.settings.dryrun:
      self.d_root.enableDryRun()
      self.d_leftovers.enableDryRun()
      self.d_stage.enableDryRun()

    # LEFTOVERS DIRECTORY: Clean the directory or create it.
    if self.d_leftovers.exists():
      self.d_leftovers.traverse()
      if len(self.d_leftovers.children):
        for c in self.d_leftovers.children:
          c.remove()
        msg(" - Leftovers directory '%s/' cleaned." % self.settings.leftoversdir)
    else:
      self.d_leftovers.mkdir()
      msg(" - Leftovers directory '%s/' created." % self.settings.leftoversdir)

    # STAGE DIRECTORY: Create the directory or verify it is empty when it exists.
    if self.d_stage.exists():
      self.d_stage.traverse()
      if len(self.d_stage.children) != 0:
        msg(" - Stage directory '%s/' exist but is NOT empty. Please investigate, aborting..." % self.settings.stagedir)
        sys.exit()
      else:
        msg(" - Stage directory '%s/' exists." % self.settings.stagedir)
    else:
      self.d_stage.mkdir()
      msg(" - Stage directory '%s/ created'." % self.settings.stagedir)

  # Traverse the base path where the music resides in and pass our registrar.
  def traverse(self):
    debug("'%s' traverse()" % self, 1)
    msg(" - Starting file system analysis.")
    self.d_root.traverse()

  # Extract all the meta data from the collected music files.
  def extract(self):
    debug("'%s' extract()" % self, 1)
    msg(" - Starting tag extraction.")
    for f in self.musicfiles:
      f.extract()

  # Sanitize all extracted meta data for file system usage and validate input.
  def sanitize(self):
    debug("'%s' sanitize()" % self, 1)
    msg(" - Sanitizing data and validation tag input.")
    for f in self.musicfiles:
      try:
        f.sanitize()
      except ValueError:
        msg("\n  Manually correct the tags of this file or the full album.\n")
        msg("  File:   '%s'" % f.relpath)
        msg("  Artist: '%s' --> '%s'" % (f.artist, f.artist_s))
        msg("  Album:  '%s' --> '%s'" % (f.album, f.album_s))
        msg("  Title:  '%s' --> '%s'" % (f.title, f.title_s))
        msg("\n - Aborted, no files have been touched.")
        sys.exit()

  # Move all the non-music files into the leftovers directory.
  def moveLeftovers(self):
    debug("'%s' moveLeftovers()" % self, 1)
    msg(" - Moving non music files to '%s/'." % self.settings.leftoversdir)

    # Iterate trough all the files and recreate their original directory path
    # within the leftovers directory to not loose their original dir structure.
    for f in self.files:
      if os.path.dirname(f.relpath) != '':
        destination = self.d_leftovers.mkdirs(os.path.dirname(f.relpath))
      else:
        destination = self.d_leftovers
      f.move(destination)

  # Rename the music files and move them into the new structure.
  def moveMusic(self):
    debug("'%s' moveMusic()" % self, 1)

  ## HOOK IMPLEMENTATIONS ######################################################

  # Register a reference to any new created file system node in this collection.
  def callbackInit(self, node):
    if id(node) in self.ids:
      return
    self.ids.append(id(node))
    if node.type is 'Directory':
      self.directories.append(node)
    elif node.type is 'File':
      self.files.append(node)
    elif node.type is 'MusicFile':
      self.musicfiles.append(node)
    else:
      self.nodes.append(node)

  # Implementation of the remove hook.
  def callbackRemove(self, node):
    pass

  # Implementation of the move hook.
  def callbackMove(self, node, dest):
    pass

  # Implementation of the sanitize hook.
  def callbackSanitize(self, node):
    pass

  # Implementation of the traverse_filter hook.
  def callbackTraverseFilter(self, node, path):

    # Skip including the leftovers and stage directories within the music tree.
    if path == self.d_leftovers.path:
      return False
    if path == self.d_stage.path:
      return False
    return True

  # Implementation of the mkdir hook.
  def callbackMkdir(self, node):
    pass

## FUNCTIONS ###################################################################

#  MAIN PHASE 1: Import all required libraries.
#
#  @returns
#   Void.
def __main_import():
  try:
    import sys, os, re, tagpy
    from unicodedata import normalize
    from datetime import datetime
    from optparse import OptionParser
    global sys, os, re, tagpy, normalize, datetime, OptionParser
  except Exception, e:
    print "ERROR: %s\n\nConsider installing packages, e.g.:" % e
    print " $ apt-get install python-tagpy"
    import sys
    sys.exit(3) # Internal error.

#  MAIN PHASE 2: Configure the option parser.
#
#  @returns
#   The propagated options dictionary.
def __main_optionparser():
  usage = "usage: %prog [OPTIONS]... [DIRECTORY]"
  parser = OptionParser(usage=usage)
  parser.add_option(
    "-d", "--dry-run",
    action="store_true", dest="dryrun", default=False,
    help="Perform a dry run and don't touch anything.")
  parser.add_option(
    "-f", "--format",
    action="store", type="string", dest="format", metavar='F',
    default='$artist/$album/$artist-$title.$ext',
    help="The format in which filenames will be rewritten.")
  parser.add_option(
    "-l", "--leftovers",
    action="store", type="string", dest="leftoversdir", metavar='L',
    default='__LEFTOVERS',
    help="The directory where non-music files will be moved to.")
  parser.add_option(
    "-s", "--stagedir",
    action="store", type="string", dest="stagedir", metavar='S',
    default='__STAGE',
    help="Temporary directory before music hits its final spot.")
  parser.add_option(
    "-q", "--quiet",
    action="store_true", dest="quiet", default=False,
    help="Silence all output completely, including debugging.")
  parser.add_option(
    "-v", "--verbose",
    action="count", dest="debuglevel", default=False, metavar='V',
    help="The level of logging verbosity, up to 5 v's.")
  (options, args) = parser.parse_args()
  return {'options': options, 'parser': parser, 'args': args}

#  MAIN PHASE 3: Validate the given arguments and prepare the options object.
#
#  @returns
#   The options object or might preliminary terminate the script if needed.
def __main_optionvalidator(settings):
  if not len(settings['args']):
    settings['parser'].print_help()
    sys.exit(0) # ok

  # Store the mandatory directory argument as setting key "dir".
  settings['options'].dir = str(settings['args'][0]).strip()

  # Test whether the path exists.
  if not os.path.exists(settings['options'].dir):
    print "ERROR: Directory '%s' not found!\n" % settings['options'].dir
    settings['parser'].print_help()
    sys.exit(3) # ERROR

  # Test whether the path is a directory as it should be.
  if not os.path.isdir(settings['options'].dir):
    print "ERROR: Path '%s' is not a directory!\n" % settings['options'].dir
    settings['parser'].print_help()
    sys.exit(3) # ERROR

  # De-construct the parser and arguments and return the settings object.
  del(settings['parser'])
  del(settings['args'])
  return settings['options']

##
##  MAIN PHASE 4: Initialize the debugger if --debug got passed in.
##
def __main_initdebugger(settings):
  global debuglevel
  global quiet
  debuglevel = settings.debuglevel
  quiet = settings.quiet
  if debuglevel:
    debug('__main_initdebugger()')

#
#  Log a message to the debugger.
#
def debug(string, indentationLevel=0):
  global debuglevel
  if not debuglevel:
    return

  # Skip messages with a higher debuglevel level.
  if indentationLevel+1 > debuglevel:
    return

  # Generate an indentation prefix.
  prefix = []
  indentationLevel = (indentationLevel * 2) + 2
  for x in range(0, indentationLevel):
    prefix.append(' ')
  prefix = ''.join(prefix)

  # Reformat and print each line.
  for line in string.split("\n"):
    msg("[%s]%s%s" % (str(datetime.utcnow()).split(" ")[1], prefix, line))

#
# Print a message to the screen.
#
def msg(string):
  global quiet
  if quiet:
    return
  print string

#
# MAIN ROUTINE.
#
def main():
  __main_import()
  settings = __main_optionvalidator(__main_optionparser())
  __main_initdebugger(settings)
  try:
    coll = Collection(settings)
    coll.traverse()
    coll.extract()
    coll.sanitize()
    coll.moveLeftovers()
    coll.moveMusic()
  except KeyboardInterrupt:
    print " Quitting, sorry..."

## MAIN SCRIPT INVOCATION ######################################################
main()