#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# mrenamer - Music file renamer
#
# @description
#  This script is a one-purpose rewriter for trees with music files. It iterates
#  trough a file hierarchy and fetches common music tags from each sound file it
#  finds and supports and uses this data to create a new file and directory
#  structure. Files found in the old hierarchy are placed in a directory
#  called "__LEFTOVERS" to not lose anything.
#
# @author
#  Niels van Mourik <niels@nielsvm.org>
#

## CLASSES #####################################################################

#
# Translate a string into a absolutely safe file system friendly representation.
#
class SafeString():
  whitelist = ('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o',
    'p','q','r','s','t','u','v','w','x','y','z','-','.', ' ', '0', '1', '2',
    '3', '4', '5', '6', '7', '8', '9')
  original = string = ''

  # Initialize the string object.
  def __init__(self, string):
    string = unicode(string)
    self.original = string
    self.string = string.lower()
    decomposed = normalize("NFKD", self.string)
    self.string = ''.join(c for c in decomposed if ord(c)<0x7f)
    self.filter()

  # Filter out any garbage left.
  def filter(self):
    result = []
    for char in self.string:
      for validchar in self.whitelist:
        if char == validchar:
          result.append(char)
    self.string = ''.join(result)

  def __str__(self):
    return self.string

#
# Represent any file, directory or other reference found on the file system.
#
class Node():
  type = ''
  path = relpath = ''
  base = ''
  root = ''
  dryrun = False
  parent = None
  callback = None
  debuglevel = 1

  # Initialize the file-system node container
  def __init__(self, path, callback = None, parent = None, debuglevel = 1):
    self.type = self.__class__.__name__
    self.path = os.path.abspath(path)
    self.base = os.path.basename(self.path)
    self.dryrun = False
    self.parent = parent
    if parent == None:
      if os.path.isdir(self.path):
        self.root = self.path
      else:
        self.root = os.path.dirname(self.path)
    else:
      self.root = self.parent.root
    self.relpath = self.path.replace('%s/' % self.root, '')
    self.debuglevel = self.debuglevel + debuglevel
    debug("'%s' __init__()" % self, self.debuglevel)

    # Pass ourselves on to the given callback (if provided).
    if callback != None:
      self.callback = callback
      callback(self)

  # Format our own base representation.
  def __str__(self):
    return "%s:%s" % (self.type, self.base)

  # Enable a dry-run mode on this object so that no real will things happen.
  def enableDryRun(self):
    self.dryrun = True

  # Delete the file system object from disk.
  def remove(self):
    debug("'%s' remove()" % self, self.debuglevel)
    if not self.dryrun:
      os.unlink(self.path)

    # Remove this instance from the parents list of children.
    if self.parent != None:
      self.parent.removeChild(self)

  # Move the file system object onto a different location.
  def move(self, dest):
    debug("'%s' move()" % self, self.debuglevel)

    # Declare the new path and physically move the object.
    self.oldpath = self.path
    self.path = os.path.abspath('%s/%s' % (dest.path, self.base))
    if not self.dryrun:
      os.rename(self.oldpath, self.path)

    # Unregister ourselves at our current parent and register at new parent.
    if self.parent:
      self.parent.removeChild(self)
      dest.addChild(self)

    # Re-parent ourselves and update several properties.
    self.parent = dest
    self.base = os.path.basename(self.path)
    self.dryrun = self.parent.dryrun
    self.root = self.parent.root
    self.relpath = self.path.replace('%s/' % self.root, '')
    self.debuglevel = self.parent.debuglevel + 1

#
# Represent an ordinary file found on the file system.
#
class File(Node):
  extension = ''

  # Initialize the file object after calling home.
  def __init__(self, path, extension, callback = None, parent = None, debuglevel = 1):
    Node.__init__(self, path, callback, parent, debuglevel)

    # Set the extension if available.
    if '.' in self.base:
      self.extension = extension
    else:
      extension = ''

#
# Represent a file of a known music file format found on the file system.
#
class MusicFile(File):
  artist = ''
  album = ''
  title = ''
  artist_s = ''
  album_s = ''
  title_s = ''

  # Initialize the music file object after calling home.
  def __init__(self, path, extension, callback = None, parent = None, debuglevel = 1):
    File.__init__(self, path, extension, callback, parent, debuglevel)

    # Reset all meta data values of this music file.
    self.artist = self.album = self.title = ''
    self.artist_s = self.album_s = self.title_s = ''

  # Extract all meta data using the Tagpy library.
  def extract(self):
    debug("'%s' extract()" % self, self.debuglevel)
    f = tagpy.FileRef(self.path, False)
    self.artist = f.tag().artist
    self.album = f.tag().album
    self.title = f.tag().title

  # Sanitize the extracted data ready for file system level usage.
  def sanitize(self):
    debug("'%s' sanitize()" % self, self.debuglevel)
    self.artist_s = str(SafeString(self.artist.strip()))
    self.album_s = str(SafeString(self.album.strip()))
    self.title_s = str(SafeString(self.title.strip()))

    # Start validating the data on field length.
    if not len(self.artist_s):
      raise ValueError(self)
    elif not len(self.album_s):
      raise ValueError(self)
    elif not len(self.title_s):
      raise ValueError(self)

#
# Represent a directory found on the file system.
#
class Directory(Node):
  children = []

  # Initialize the file object after calling home.
  def __init__(self, path, callback = None, parent = None, debuglevel = 1):
    Node.__init__(self, path, callback, parent, debuglevel)
    self.children = []

  # Enable a dry-run mode on this object and its children.
  def enableDryRun(self):
    Node.enableDryRun(self)
    if len(self.children):
      for c in self.children:
        c.enableDryRun()

  # Add a child node.
  def addChild(self, child):
    children = []
    for c in self.children:
      children.append(c)
    children.append(child)
    self.children = children

  # Remove a child from this node.
  def removeChild(self, child):
    children = []
    for c in self.children:
      if c.path != child.path:
        children.append(c)
    self.children = children

  # Traverse into subdirectories and load our children.
  def traverse(self):
    self.children = []
    debug("'%s' traverse()" % self, self.debuglevel)
    for path in os.listdir(self.path):
      debuglevel = self.debuglevel + 1
      path = "%s/%s" % (self.path, path)

      # Perform a set of tests and load the correct class for the found child.
      if os.path.isdir(path):
        node = Directory(path, self.callback, self, debuglevel)
        node.traverse()
      elif os.path.isfile(path):
        music_extensions = ('mp3', 'ogg', 'flac')
        extension = path.split('.').pop()
        if extension in music_extensions:
          node = MusicFile(path, extension, self.callback, self, debuglevel)
        else:
          node = File(path, extension, self.callback, self, debuglevel)
      else:
        node = Node(path, self.callback, self, debuglevel)

      # If a --dry-run policy is applied onto us; our children inherit this.
      if self.dryrun:
        node.enableDryRun()

      # Append the child to our list of children.
      self.children.append(node)

  # Make this directory if it doesn't exist on disk yet.
  def mkdir(self):
    debug("'%s' mkdir()" % self, self.debuglevel)
    if not self.dryrun:
      os.mkdir(self.path)

  # Make multiple directories at once and assure that a path exists.
  def mkdirs(self, path):
    debug("'%s' mkdirs()" % self, self.debuglevel)

    # Calculate the sub path and current base being looked for.
    path = path.split('/')
    base = path[0]
    del path[0]

    # Determine whether the top level of the trail already exists.
    existingDir = False
    for c in self.children:
      if c.base == base:
        existingDir = c

    # Load the new directory object and create it if needed.
    if not existingDir:
      debuglevel = self.debuglevel + 1
      npath = "%s/%s" % (self.path, base)
      dir = Directory(npath, self.callback, self, debuglevel)
      if self.dryrun:
        dir.enableDryRun()
      dir.mkdir()
      self.children.append(dir)
    else:
      dir = existingDir

    # Let the fresh directory object recurse into itself.
    if len(path):
      return dir.mkdirs('/'.join(path))
    return dir

  # Delete this directory and it's siblings from disk.
  def remove(self):
    debug("'%s' remove()" % self, self.debuglevel)

    # Start with removing my children and their references.
    for c in self.children:
      c.remove()
    self.children = []

    # Remove the directory when it's emptied.
    if not self.dryrun:
      os.rmdir(self.path)

    # Remove this instance from the parents list of children.
    if self.parent != None:
      self.parent.removeChild(self)

  # Move the file system object onto a different location.
  def move(self, dest):
    debug("'%s' move()" % self, self.debuglevel)
    raise Exception("Can not move directories yet...")

#
# Represent the collection of all found file objects within the base path.
#
class Collection():
  settings = root = leftovers = None
  directories = []
  musicfiles = []
  files = []
  nodes = []

  # Initialize the music collection.
  def __init__(self, settings):
    debug("'%s' __init__()" % self, 1)
    self.settings = settings

    # Initialize the base music directory object.
    self.root = Directory(self.settings.dir, self.nodeRegistrar)

    # Initialize the leftovers directory and it's directory object.
    leftoversdir = "%s/%s" % (self.root.path, self.settings.leftovers)
    self.leftovers = Directory(leftoversdir, None, self.root, 2)

    # If --dry-run was passed we enable the safe mode on both root objects.
    if self.settings.dryrun:
      self.root.enableDryRun()
      self.leftovers.enableDryRun()

    # The leftovers directory is initialized, but not yet created and emptied...
    if not os.path.exists(self.leftovers.path):
      self.leftovers.mkdir()
      msg(" - Created directory '%s/'." % self.settings.leftovers)
    self.leftovers.traverse()
    if len(self.leftovers.children):
      for c in self.leftovers.children:
        c.remove()
      msg(" - Cleaned directory '%s/'." % self.settings.leftovers)

  # Register a reference to any new created file system node in this collection.
  def nodeRegistrar(self, node):
    if node.type is 'Directory':
      self.directories.append(node)
    elif node.type is 'File':
      self.files.append(node)
    elif node.type is 'MusicFile':
      self.musicfiles.append(node)
    else:
      self.nodes.append(node)

  # Traverse the base path where the music resides in and pass our registrar.
  def traverse(self):
    debug("'%s' traverse()" % self, 1)
    msg(" - Starting file system analysis.")
    self.root.traverse()

    # The leftovers directory is our safe haven and already has a separate root
    # object on self.leftovers. It got scanned twice, let's remove this reference.
    self.root.removeChild(self.leftovers)

  # Extract all the meta data from the collected music files.
  def extract(self):
    debug("'%s' extract()" % self, 1)
    msg(" - Starting tag extraction.")
    for f in self.musicfiles:
      f.extract()

  # Sanitize all extracted meta data for file system usage and validate input.
  def sanitize(self):
    debug("'%s' sanitize()" % self, 1)
    msg(" - Sanitizing data and validation tag input.")
    for f in self.musicfiles:
      try:
        f.sanitize()
      except ValueError:
        msg("\n  Manually correct the tags of this file or the full album.\n")
        msg("  File:   '%s'" % f.relpath)
        msg("  Artist: '%s' --> '%s'" % (f.artist, f.artist_s))
        msg("  Album:  '%s' --> '%s'" % (f.album, f.album_s))
        msg("  Title:  '%s' --> '%s'" % (f.title, f.title_s))
        msg("\n - Aborted, no files have been touched.")
        sys.exit()

  # Move all the non-music files into the leftovers directory.
  def moveLeftovers(self):
    debug("'%s' move_leftovers()" % self, 1)
    msg(" - Moving non music files to '%s/'." % self.settings.leftovers)

    # Iterate trough all the files and recreate their original directory path
    # within the leftovers directory to not loose their original dir structure.
    for f in self.files:
      if os.path.dirname(f.relpath) != '':
        destination = self.leftovers.mkdirs(os.path.dirname(f.relpath))
      else:
        destination = self.leftovers
      f.move(destination)

## FUNCTIONS ###################################################################

#  MAIN PHASE 1: Import all required libraries.
#
#  @returns
#   Void.
def __main_import():
  try:
    import sys, os, re, tagpy
    from unicodedata import normalize
    from datetime import datetime
    from optparse import OptionParser
    global sys, os, re, tagpy, normalize, datetime, OptionParser
  except Exception, e:
    print "ERROR: %s\n\nConsider installing packages, e.g.:" % e
    print " $ apt-get install python-tagpy"
    import sys
    sys.exit(3) # Internal error.

#  MAIN PHASE 2: Configure the option parser.
#
#  @returns
#   The propagated options dictionary.
def __main_optionparser():
  usage = "usage: %prog [OPTIONS]... [DIRECTORY]"
  parser = OptionParser(usage=usage)
  parser.add_option(
    "-d", "--dry-run",
    action="store_true", dest="dryrun", default=False,
    help="Perform a dry run and don't touch anything.")
  parser.add_option(
    "-f", "--format",
    action="store", type="string", dest="format", metavar='F',
    default='$artist/$album/$artist-$title.$ext',
    help="The format in which filenames will be rewritten.")
  parser.add_option(
    "-l", "--leftovers",
    action="store", type="string", dest="leftovers", metavar='L',
    default='__LEFTOVERS',
    help="The directory where non-music files will be moved to.")
  parser.add_option(
    "-q", "--quiet",
    action="store_true", dest="quiet", default=False,
    help="Silence all output completely, including debugging.")
  parser.add_option(
    "-v", "--verbose",
    action="count", dest="debuglevel", default=False, metavar='V',
    help="The level of logging verbosity, up to 5 v's.")
  (options, args) = parser.parse_args()
  return {'options': options, 'parser': parser, 'args': args}

#  MAIN PHASE 3: Validate the given arguments and prepare the options object.
#
#  @returns
#   The options object or might preliminary terminate the script if needed.
def __main_optionvalidator(settings):
  if not len(settings['args']):
    settings['parser'].print_help()
    sys.exit(0) # ok

  # Store the mandatory directory argument as setting key "dir".
  settings['options'].dir = str(settings['args'][0]).strip()

  # Test whether the path exists.
  if not os.path.exists(settings['options'].dir):
    print "ERROR: Directory '%s' not found!\n" % settings['options'].dir
    settings['parser'].print_help()
    sys.exit(3) # ERROR

  # Test whether the path is a directory as it should be.
  if not os.path.isdir(settings['options'].dir):
    print "ERROR: Path '%s' is not a directory!\n" % settings['options'].dir
    settings['parser'].print_help()
    sys.exit(3) # ERROR

  # De-construct the parser and arguments and return the settings object.
  del(settings['parser'])
  del(settings['args'])
  return settings['options']

##
##  MAIN PHASE 4: Initialize the debugger if --debug got passed in.
##
def __main_initdebugger(settings):
  global debuglevel
  global quiet
  debuglevel = settings.debuglevel
  quiet = settings.quiet
  if debuglevel:
    debug('__main_initdebugger()')

#
#  Log a message to the debugger.
#
def debug(string, indentationLevel=0):
  global debuglevel
  if not debuglevel:
    return

  # Skip messages with a higher debuglevel level.
  if indentationLevel+1 > debuglevel:
    return

  # Generate an indentation prefix.
  prefix = []
  indentationLevel = (indentationLevel * 2) + 2
  for x in range(0, indentationLevel):
    prefix.append(' ')
  prefix = ''.join(prefix)

  # Reformat and print each line.
  for line in string.split("\n"):
    msg("[%s]%s%s" % (str(datetime.utcnow()).split(" ")[1], prefix, line))

#
# Print a message to the screen.
#
def msg(string):
  global quiet
  if quiet:
    return
  print string

#
# MAIN ROUTINE.
#
def main():
  __main_import()
  settings = __main_optionvalidator(__main_optionparser())
  __main_initdebugger(settings)
  try:
    coll = Collection(settings)
    coll.traverse()
    coll.extract()
    coll.sanitize()
    coll.moveLeftovers()
  except KeyboardInterrupt:
    print " Quitting, sorry..."

## MAIN SCRIPT INVOCATION ######################################################
main()